package main

import (
	"bytes"
	"go/ast"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/grm.v1"
	"gopkg.in/grm.v1/rows"
)

var _sql = `// Code generated by "{{.By}}"; DO NOT EDIT.

package {{.Pkg}}

import (
	"log"
	"text/template"
	"time"

	"gopkg.in/grm.v1/rows"
	"gopkg.in/grm.v1"
)

var (
	begin     = time.Now()
	MaxLimit  = {{.MaxLimit}}                        // Max read rows limit
	FieldName = rows.MakeFieldName("{{.FieldName}}") // Field name
	MaxFork   = {{.MaxFork}}                         // Max fork
	Template  = template.New("{{.Pkg}}")             // template
	Path      = "{{.Path}}"                          // template file path
	Println   = log.Println                          // logger
)

func init() {
	Template.Funcs(grm.Funcs)
	template.Must(grm.ParseSqlFiles(Template, Path))
}

{{range .Methods}}
{{if eq .Type "Select"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBQuery{{if .Req}}, req *Req{{.Name}}{{end}}) (resp {{.Slice}}*Resp{{.Name}},err error) {
	name := "{{.Name}}"
	
	var sql string
	sql, err = grm.Execute(Template.Lookup(name), {{if .Req}}req{{else}}nil{{end}})
	if err != nil {
		return 
	}
	
	if Println != nil {
		Println(sql)
	}

	if db == nil {
		db, err = grm.Get()
		if err != nil {
			return
		}
	}
	
	_, err = grm.Query(db, sql, {{if .Req}}req{{else}}nil{{end}}, &resp, MaxLimit, FieldName, MaxFork)
	return
}
{{if .Req}}
// Req{{.Name}} ...
//line {{.Line}}
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} {{.Tags}} // {{.Comment}}{{end}}
}

//line {{.Line}}
func (r Req{{.Name}}) {{.Name}}(db grm.DBQuery) (resp *Resp{{.Name}}, err error) {
	return {{.Name}}(db, &r)
}
{{end}}
// Resp{{.Name}} ...
//line {{.Line}}
type Resp{{.Name}} struct { {{range .Resp}}
	{{.Name}} {{.Type}} {{.Tags}} // {{.Comment}}{{end}}
}
{{else if eq .Type "Update"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBExec{{if .Req}}, req *Req{{.Name}}{{end}}) (count int,err error) {
	name := "{{.Name}}"
	
	var sql string
	sql, err = grm.Execute(Template.Lookup(name), {{if .Req}}req{{else}}nil{{end}})
	if err != nil {
		return 
	}
	
	if Println != nil {
		Println(sql)
	}
	
	if db == nil {
		db, err = grm.Get()
		if err != nil {
			return
		}
	}
	
	return grm.ExecRowsAffected(db, sql, {{if .Req}}req{{else}}nil{{end}})
}
{{if .Req}}
// Req{{.Name}} ...
//line {{.Line}}
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} {{.Tags}} // {{.Comment}}{{end}}
}

//line {{.Line}}
func (r Req{{.Name}}) {{.Name}}(db grm.DBQuery) (resp *Resp{{.Name}}, err error) {
	return {{.Name}}(db, &r)
}
{{end}}
{{else if eq .Type "Delete"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBExec{{if .Req}}, req *Req{{.Name}}{{end}}) (count int,err error) {
	name := "{{.Name}}"
	
	var sql string
	sql, err = grm.Execute(Template.Lookup(name), {{if .Req}}req{{else}}nil{{end}})
	if err != nil {
		return 
	}
	
	if Println != nil {
		Println(sql)
	}

	if db == nil {
		db, err = grm.Get()
		if err != nil {
			return
		}
	}
	
	return grm.ExecRowsAffected(db, sql, {{if .Req}}req{{else}}nil{{end}})
}
{{if .Req}}
// Req{{.Name}} ...
//line {{.Line}}
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} {{.Tags}} // {{.Comment}}{{end}}
}

//line {{.Line}}
func (r Req{{.Name}}) {{.Name}}(db grm.DBQuery) (resp *Resp{{.Name}}, err error) {
	return {{.Name}}(db, &r)
}
{{end}}
{{else if eq .Type "Insert"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBExec{{if .Req}}, req *Req{{.Name}}{{end}}) (count int,err error) {
	name := "{{.Name}}"
	
	var sql string
	sql, err = grm.Execute(Template.Lookup(name), {{if .Req}}req{{else}}nil{{end}})
	if err != nil {
		return 
	}
	
	if Println != nil {
		Println(sql)
	}

	if db == nil {
		db, err = grm.Get()
		if err != nil {
			return
		}
	}
	
	return grm.ExecLastInsertId(db, sql, {{if .Req}}req{{else}}nil{{end}})
}
{{if .Req}}
// Req{{.Name}} ...
//line {{.Line}}
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} {{.Tags}} // {{.Comment}}{{end}}
}

//line {{.Line}}
func (r Req{{.Name}}) {{.Name}}(db grm.DBQuery) (resp *Resp{{.Name}}, err error) {
	return {{.Name}}(db, &r)
}
{{end}}
{{else if eq .Type "Exec"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBExec{{if .Req}}, req *Req{{.Name}}{{end}}) (err error) {
	name := "{{.Name}}"

	var sql string
	sql, err = grm.Execute(Template.Lookup(name), {{if .Req}}req{{else}}nil{{end}})
	if err != nil {
		return 
	}
	
	if Println != nil {
		Println(sql)
	}
	
	if db == nil {
		db, err = grm.Get()
		if err != nil {
			return
		}
	}
	
	_, err = grm.Exec(db, sql, {{if .Req}}req{{else}}nil{{end}})
	return err
}
{{if .Req}}
// Req{{.Name}} ...
//line {{.Line}}
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} {{.Tags}} // {{.Comment}}{{end}}
}

//line {{.Line}}
func (r Req{{.Name}}) {{.Name}}(db grm.DBQuery) (resp *Resp{{.Name}}, err error) {
	return {{.Name}}(db, &r)
}
{{end}}
{{end}}
{{end}}
`

var tpl, _ = template.New("").Parse(_sql)

func MakeTplData(data *TplData) []byte {
	buf := bytes.NewBuffer(nil)
	tpl.Execute(buf, data)
	return buf.Bytes()
}

type TplData struct {
	Pkg       string
	By        string
	MaxLimit  int
	MaxFork   int
	Path      string
	FieldName string
	Methods   []*Method
}

type Method struct {
	Line    string
	Name    string
	Type    string
	Comment string
	Slice   string
	Req     []*Parameter
	Resp    []*Parameter
}

type Parameter struct {
	Name    string
	Type    string
	Tags    string
	Comment string
}

func ParseMethods(t []*template.Template) ([]*Method, error) {
	b := []*Method{}
	for _, v := range t {
		name := v.Name()
		parseName := v.ParseName
		if parseName == name || !ast.IsExported(name) {
			continue
		}
		con := v.Tree.Root.String()
		ss := strings.Split(con, "\n")

		ss0 := []string{}
		for _, v := range ss {
			if strings.HasPrefix(v, "--") {
				if len(v) == 2 {
					break
				}
				ss0 = append(ss0, v[2:])
			}
		}

		l, _ := v.ErrorContext(v.Tree.Root)

		if ci := strings.LastIndex(l, ":"); ci >= 0 {
			l = l[:ci]
		}
		m := &Method{
			Line: l,
			Name: v.Tree.Name,
		}

		dd, err := grm.ReadAtLine(bytes.NewBufferString(strings.Join(ss0, "\n")))
		if err != nil {
			return nil, err
		}

		for _, v := range dd {
			if len(v) < 1 {
				continue
			}
			switch v[0] {
			case "@Type":
				if len(v) >= 2 {
					m.Type = v[1]
				}
				if len(v) >= 3 {
					m.Slice = v[2]
				}
			case "@Comm":
				if len(v) >= 2 {
					m.Comment += v[1]
					m.Comment += " "
				}

			case "@Req":
				if len(v) >= 4 {
					m.Req = append(m.Req, NewParameter(v))
				}
			case "@Resp":
				if len(v) >= 4 {
					m.Resp = append(m.Resp, NewParameter(v))
				}
			}
		}

		b = append(b, m)
	}

	return b, nil
}

func NewParameter(v []string) *Parameter {
	ts := []string{}
	com := ""
	if len(v) >= 3 {
		ts = v[3 : len(v)-1]
		com = v[len(v)-1]
	}
	b := true

	t := "sql:"
	for _, v := range ts {
		if strings.Index(v, t) == 0 {
			b = false
			break
		}
	}

	if b {
		ts = append(ts, t+`"`+rows.Hump2Snake(v[1])+`"`)
	}

	sort.Strings(ts)
	return &Parameter{
		Name:    v[1],
		Type:    v[2],
		Tags:    "`" + strings.Join(ts, " ") + "`",
		Comment: com,
	}
}
