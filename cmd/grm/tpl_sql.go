package main

import (
	"bytes"
	"go/ast"
	"strings"
	"text/template"

	"gopkg.in/grm.v1"
)

var _sql = `// Code generated by "{{.By}}"; DO NOT EDIT.

package {{.Pkg}}

import (
	"text/template"
	"time"

	"gopkg.in/go-grm/rows.v1"
	"gopkg.in/grm.v1"
)

var (
	begin     = time.Now()
	MaxLimit  = {{.MaxLimit}}                        // Max read rows limit
	FieldName = rows.MakeFieldName("{{.FieldName}}") // Field name
	MaxFork   = {{.MaxFork}}                         // Max fork
	Template  = template.New("{{.Pkg}}")             // template
	Path      = "{{.Path}}"                          // template file path
)

func init() {
	Template.Funcs(grm.Funcs)
	template.Must(grm.ParseSqlFiles(Template, 1, Path))
}

{{range .Methods}}
{{if eq .Type "Select"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBQuery, req *Req{{.Name}}) (resp {{.Slice}}*Resp{{.Name}},err error) {
	name := "{{.Name}}"
	data := grm.BaseData{
		Name: name,
		Data: req,
	}
	_, err = grm.Query(db, Template.Lookup(name), data, &resp, MaxLimit, FieldName, MaxFork)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
// Req{{.Name}} ...
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} // {{.Comment}}{{end}}
}
// Resp{{.Name}} ...
type Resp{{.Name}} struct { {{range .Resp}}
	{{.Name}} {{.Type}} // {{.Comment}}{{end}}
}
{{else if eq .Type "Update"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBExec, req *Req{{.Name}}) (count int,err error) {
	name := "{{.Name}}"
	data := grm.BaseData{
		Name: name,
		Data: req,
	}
	return grm.ExecRowsAffected(db, Template.Lookup(name), data)
}
// Req{{.Name}} ...
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} // {{.Comment}}{{end}}
}
{{else if eq .Type "Delete"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBExec, req *Req{{.Name}}) (count int,err error) {
	name := "{{.Name}}"
	data := grm.BaseData{
		Name: name,
		Data: req,
	}
	return grm.ExecRowsAffected(db, Template.Lookup(name), data)
}
// Req{{.Name}} ...
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} // {{.Comment}}{{end}}
}
{{else if eq .Type "Insert"}}
// {{.Name}} {{.Comment}}
//line {{.Line}}
func {{.Name}}(db grm.DBExec, req *Req{{.Name}}) (count int,err error) {
	name := "{{.Name}}"
	data := grm.BaseData{
		Name: name,
		Data: req,
	}
	return grm.ExecLastInsertId(db, Template.Lookup(name), data)
}
// Req{{.Name}} ...
type Req{{.Name}} struct { {{range .Req}}
	{{.Name}} {{.Type}} // {{.Comment}}{{end}}
}
{{end}}
{{end}}
`

var tpl, _ = template.New("").Parse(_sql)

func MakeTplData(data *TplData) []byte {
	buf := bytes.NewBuffer(nil)
	tpl.Execute(buf, data)
	return buf.Bytes()
}

type TplData struct {
	Pkg       string
	By        string
	MaxLimit  int
	MaxFork   int
	Path      string
	FieldName string
	Methods   []*Method
}

type Method struct {
	Line    string
	Name    string
	Type    string
	Comment string
	Slice   string
	Req     []*Parameter
	Resp    []*Parameter
}

type Parameter struct {
	Name    string
	Type    string
	Comment string
}

func ParseMethods(t []*template.Template) ([]*Method, error) {
	b := []*Method{}
	for _, v := range t {
		name := v.Name()
		parseName := v.ParseName
		if parseName == name || !ast.IsExported(name) {
			continue
		}
		con := v.Tree.Root.String()
		ss := strings.Split(con, "\n")
		ss0 := []string{}
		for _, v := range ss {
			if strings.HasPrefix(v, "--") {
				if len(v) == 2 {
					break
				}
				ss0 = append(ss0, v[2:])
			}
		}

		l, _ := v.ErrorContext(v.Tree.Root)
		m := &Method{
			Line: l,
			Name: v.Tree.Name,
		}

		dd, err := grm.ReadAtLine(bytes.NewBufferString(strings.Join(ss0, "\n")))
		if err != nil {
			return nil, err
		}

		for _, v := range dd {
			if len(v) < 1 {
				continue
			}
			switch v[0] {
			case "@Type":
				if len(v) >= 2 {
					m.Type = v[1]
				}
				if len(v) >= 3 {
					m.Slice = v[2]
				}
			case "@Comm":
				if len(v) >= 2 {
					m.Comment += v[1]
					m.Comment += " "
				}
			case "@Req":
				if len(v) >= 4 {
					m.Req = append(m.Req, &Parameter{
						Name:    v[1],
						Type:    v[2],
						Comment: v[3],
					})
				}
			case "@Resp":
				if len(v) >= 4 {
					m.Resp = append(m.Resp, &Parameter{
						Name:    v[1],
						Type:    v[2],
						Comment: v[3],
					})
				}
			}
		}

		b = append(b, m)
	}

	return b, nil
}
